/**
 * bits.ts - 位操作工具
 * 
 * 这个文件提供了位级操作的功能，特别是循环移位操作。
 * 在许多加密算法、哈希函数和其他底层数据处理中，位操作是非常基础和重要的。
 * 
 * 循环移位是什么？
 * 循环移位是指将数字的二进制表示向左或向右移动特定位数，同时将"溢出"的位放回到另一端。
 * 与普通的移位不同，循环移位不会丢失任何位，而是将它们"循环"回来。
 * 
 * 例如，对8位二进制数10110101进行向右循环移位3位:
 * 原始数:    10110101
 * 结果:      10110110
 * 
 * 这里最右边的3位(101)被移到了最左边，而其他位向右移动了3位。
 * 
 * 应用场景：
 * 循环移位在密码学算法(如SHA、MD5)、数据压缩、校验和计算等领域有广泛应用。
 */

/**
 * 32位数字向左循环移位
 * 
 * 将一个32位无符号整数向左循环移位n位。
 * 也就是说，最左边的n位会"溢出"并被放置在结果的最右边。
 * 
 * 实现原理：
 * 1. x << n 得到左移n位的结果，但左边的n位被丢弃
 * 2. x >>> (32 - n) 将数字右移(32-n)位，使得原来左边的n位出现在结果的右边
 * 3. 用 | 运算符将两个结果合并
 * 4. 最后的 >>> 0 确保结果被当作无符号32位整数处理
 * 
 * 例如，对10110101(十进制181)循环左移3位:
 * 原始数:     00000000 00000000 00000000 10110101
 * 左移3位:    00000000 00000000 00000010 11010100
 * 右移29位:   00000000 00000000 00000000 00000001
 * 结果合并:   00000000 00000000 00000010 11010101 (十进制1445)
 * 
 * @param x 要移位的32位无符号整数
 * @param n 向左移位的位数
 * @returns 循环移位后的结果
 */
export function rotl32(x: number, n: number): number {
	return ((x << n) | (x >>> (32 - n))) >>> 0;
}

/**
 * 32位数字向右循环移位
 * 
 * 将一个32位无符号整数向右循环移位n位。
 * 最右边的n位会"溢出"并被放置在结果的最左边。
 * 
 * 实现原理：
 * 1. x >>> n 得到右移n位的结果，但右边的n位被丢弃
 * 2. x << (32 - n) 将数字左移(32-n)位，使得原来右边的n位出现在结果的左边
 * 3. 用 | 运算符将两个结果合并
 * 4. 最后的 >>> 0 确保结果被当作无符号32位整数处理
 * 
 * @param x 要移位的32位无符号整数
 * @param n 向右移位的位数
 * @returns 循环移位后的结果
 */
export function rotr32(x: number, n: number): number {
	return ((x << (32 - n)) | (x >>> n)) >>> 0;
}

/**
 * 64位数字向右循环移位
 * 
 * 将一个64位无符号整数(BigInt类型)向右循环移位n位。
 * 由于JavaScript普通number不能精确表示64位整数，所以使用BigInt类型。
 * 
 * 原理与32位版本类似，但使用BigInt运算符。
 * 最后的 & 0xffffffffffffffffn 操作确保结果保持为64位(类似于32位版本中的 >>> 0)。
 * 
 * @param x 要移位的64位无符号整数(BigInt类型)
 * @param n 向右移位的位数
 * @returns 循环移位后的结果(BigInt类型)
 */
export function rotr64(x: bigint, n: number): bigint {
	return ((x << BigInt(64 - n)) | (x >> BigInt(n))) & 0xffffffffffffffffn;
}

/**
 * 64位数字向左循环移位
 * 
 * 将一个64位无符号整数(BigInt类型)向左循环移位n位。
 * 
 * 原理与32位版本类似，但使用BigInt运算符。
 * 最后的 & 0xffffffffffffffffn 操作确保结果保持为64位。
 * 
 * 注意：在位运算中，BigInt使用 >> 而不是 >>> 进行右移，因为BigInt没有 >>> 运算符。
 * 但这没关系，因为我们在最后用与操作(&)截断到64位。
 * 
 * @param x 要移位的64位无符号整数(BigInt类型)
 * @param n 向左移位的位数
 * @returns 循环移位后的结果(BigInt类型)
 */
export function rotl64(x: bigint, n: number): bigint {
	return ((x << BigInt(n)) | (x >> BigInt(64 - n))) & 0xffffffffffffffffn;
}
