/**
 * bits.test.ts - bits.ts 的测试文件
 * 
 * 这个文件包含了针对 `src/bits.ts` 文件中位旋转函数的单元测试。
 * 测试的目的是确保 32 位和 64 位整数的左旋 (rotl) 和右旋 (rotr) 操作能够正确执行。
 * 旋转操作是指将数字的二进制位向左或向右移动，移出的位会从另一端循环回来。
 * 
 * 我们使用了 `vitest` 这个测试框架。
 * `test` 定义了具体的测试用例。
 */
import { test, expect } from "vitest";
import { rotl32, rotr32, rotl64, rotr64 } from "./bits.js";

// 测试 32 位整数左旋 (Rotate Left 32-bit)
// rotl32(value, amount): 将 value 的二进制表示向左旋转 amount 位
test("rotl32()", () => {
	// 输入值: 0b11110000...0000 (最高的4位是1)
	// 旋转位数: 2
	// 预期结果: 0b110000...000011 (最高的两位1移到最右边)
	expect(rotl32(0b11110000000000000000000000000000, 2)).toBe(0b11000000000000000000000000000011);
});

// 测试 32 位整数右旋 (Rotate Right 32-bit)
// rotr32(value, amount): 将 value 的二进制表示向右旋转 amount 位
test("rotr32()", () => {
	// 输入值: 0b0000...00001111 (最低的4位是1)
	// 旋转位数: 2
	// 预期结果: 0b110000...00000011 (最低的两位1移到最左边)
	expect(rotr32(0b00000000000000000000000000001111, 2)).toBe(0b11000000000000000000000000000011);
});

// 测试 64 位整数左旋 (Rotate Left 64-bit)，使用 BigInt
// rotl64(value, amount): 将 value (BigInt) 的二进制表示向左旋转 amount 位
test("rotl64()", () => {
	// 输入值: 0b111100...0000n (最高的4位是1，64位)
	// 旋转位数: 2
	// 预期结果: 0b110000...000011n (最高的两位1移到最右边，64位)
	expect(rotl64(0b1111000000000000000000000000000000000000000000000000000000000000n, 2)).toBe(
		0b1100000000000000000000000000000000000000000000000000000000000011n
	);
});

// 测试 64 位整数右旋 (Rotate Right 64-bit)，使用 BigInt
// rotr64(value, amount): 将 value (BigInt) 的二进制表示向右旋转 amount 位
test("rotr64()", () => {
	// 输入值: 0b0000...00001111n (最低的4位是1，64位)
	// 旋转位数: 2
	// 预期结果: 0b110000...00000011n (最低的两位1移到最左边，64位)
	expect(rotr64(0b0000000000000000000000000000000000000000000000000000000000001111n, 2)).toBe(
		0b1100000000000000000000000000000000000000000000000000000000000011n
	);
});
